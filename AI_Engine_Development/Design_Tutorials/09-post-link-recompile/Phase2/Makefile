#  (c) Copyright 2021 Xilinx, Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Makefile input options
TARGET ?= hw_emu
PFM := Phase1_container

#Directories
AIE:= ../Files/AIE2
PS:=../Files/PS/src

# File names and locations
GRAPH := ${AIE}/src/graph.cpp
GRAPH_O := libadf.a


# Local Install
#LOCAL := /scratch/oliviert/LocalInstall_2021.2
PLATFORM_SW := ${PLATFORM_REPO_PATHS}/xilinx_vck190_base_202120_1/sw/xilinx_vck190_base_202120_1/

NEW_PLATFORM := ./platform_repo/Phase1_container/export/Phase1_container/Phase1_container.xpfm
XCLBIN := ../Phase1/Phase1_container.xclbin

ROOTFS  := ${PLATFORM_REPO_PATHS}/sw/versal/xilinx-versal-common-v2021.2/rootfs.ext4
NEW_ROOTFS := $(ROOTFS)
NEW_IMAGE   := ${PLATFORM_REPO_PATHS}/sw/versal/xilinx-versal-common-v2021.2/Image
SYSROOT := ${PLATFORM_REPO_PATHS}/sw/versal/xilinx-versal-common-v2021.2/sysroots

# XRT_IMAGE   := ${LOCAL}/platforms/xilinx_vck190_base_202120_1/sw/xilinx_vck190_base_202120_1/xrt/image
# BIF := ${LOCAL}/platforms/xilinx_vck190_base_202120_1/sw/xilinx_vck190_base_202120_1/boot/linux.bif
# BOOT := ${LOCAL}/platforms/xilinx_vck190_base_202120_1/sw/xilinx_vck190_base_202120_1/boot
# QEMU := ${LOCAL}/platforms/xilinx_vck190_base_202120_1/sw/xilinx_vck190_base_202120_1/qemu
XRT_IMAGE   := ${PLATFORM_SW}/xrt/image
BIF := ${PLATFORM_SW}/boot/linux.bif
BOOT := ${PLATFORM_SW}/boot
QEMU := ${PLATFORM_SW}/qemu

# Command-line options
VPP := v++
AIECC := aiecompiler
# Embedded platform, we need the A72 compiler
CXX := aarch64-linux-gnu-g++

AIE_INCLUDE_FLAGS := -include="$(XILINX_VITIS)/aietools/include" -include="${AIE}/src" -include="${AIE}/data" -include="${AIE}/src/aie_kernels" -include="${PL}/src"
AIE_FLAGS := --target=hw $(AIE_INCLUDE_FLAGS) --pl-freq=200 -workdir=./Work -platform=${NEW_PLATFORM}


GCC_FLAGS := -Wall -c \
			 -std=c++1y \
			 -Wno-int-to-pointer-cast \
			 --sysroot=./platform_repo/Phase1_container/export/Phase1_container/sw/Phase1_container/xrt/sysroot/aarch64-xilinx-linux
#			 -D__PS_ENABLE_AIE__ \
#			 -D__linux__ \
#			 -D__USE_XOPEN2K8__

GCC_INCLUDES := -I$(SYSROOT)/usr/include/xrt \
				-I$(SYSROOT)/usr/include \
				-I./ -I${AIE}/src \
				-I$(XILINX_VITIS)/aietools/include \
				-I$(XILINX_VITIS)/include \
				-I$(XILINX_VITIS)/../../Vitis_HLS/2021.2/include \
				-I${PS} \
				-I./platform_repo/Phase1_container/export/Phase1_container/sw/Phase1_container/xrt/sysroot/aarch64-xilinx-linux/usr/include \
				-I./platform_repo/Phase1_container/export/Phase1_container/sw/Phase1_container/xrt/sysroot/aarch64-xilinx-linux/usr/include/xrt \
				-I$(XILINX_VIVADO)/include


GCC_LIB := -lxaiengine -ladf_api_xrt -lxrt_core -lxrt_coreutil \
			 --sysroot=./platform_repo/Phase1_container/export/Phase1_container/sw/Phase1_container/xrt/sysroot/aarch64-xilinx-linux \
			 -L./platform_repo/Phase1_container/export/Phase1_container/sw/Phase1_container/xrt/sysroot/aarch64-xilinx-linux/usr/lib \
		   -L${XILINX_VITIS}/aietools/lib/aarch64.o \
			 -L${XILINX_VITIS}/aietools/lib/lnx64.o

.ONESHELL:
.PHONY: clean all  aie  host package run_emu

guard-%:
	@#$(${$*}, $(error $* is not set. Run: environment-setup-aarch64-xilinx-linux))

all:  pfm aie  host package

# xsct_create_pfm has 8 parameters
# Platform names
# Directory of the xsa and xclbin
#  ROOTFS file
#  SYSROOT directory
# Directory of the qemu
# Image
# BOOT
# BIF file
pfm:
		xsct xsct_create_pfm.tcl ${PFM} ../Phase1 ${ROOTFS} ${SYSROOT} ${QEMU} ${XRT_IMAGE} ${BOOT} ${BIF}

######################################################
# This step  creates an ADF Graph
# The graph is generated by having the -target=hw

aie: $(GRAPH_O)

aiesim: $(GRAPH_O)
	aiesmulator --pkg-dir=./Work

$(GRAPH_O): $(GRAPH)
	$(AIECC) $(AIE_FLAGS) $(GRAPH)
	@echo "COMPLETE: libadf.a created."
#####################################################


############################################################################################################################
# For hardware and hardware emulation, compile the PS code and generate the host.exe. This is needed for creating the sd_card.


host:
	$(CXX) $(GCC_FLAGS) $(GCC_INCLUDES) -o aie_control_xrt.o ./Work/ps/c_rts/aie_control_xrt.cpp
	$(CXX) $(GCC_FLAGS) $(GCC_INCLUDES) -o main.o ${PS}/host.cpp
	$(CXX) $(GCC_FLAGS) $(GCC_INCLUDES) -o helper.o ${PS}/helper_functions.cpp
	$(CXX) *.o $(GCC_LIB) -std=c++14 -o host.exe
	@echo "COMPLETE: Host application created."
############################################################################################################################

##################################################################################################
# Depending on the TARGET, it'll either generate the PDI for hw_emu or hw.
package:
ifeq (${TARGET},hw_emu)
	$(VPP) -p -t hw_emu \
		-f ${NEW_PLATFORM} \
		--package.rootfs=${NEW_ROOTFS} \
		--package.image_format=ext4 \
		--package.boot_mode=sd \
		--package.kernel_image=${NEW_IMAGE} \
		--package.defer_aie_run \
		--package.sd_file host.exe $(XCLBIN) libadf.a
	@echo "COMPLETE: hw_emu package created."
else
	v++ -p -t hw \
		-f ${NEW_PLATFORM} \
		--package.rootfs=${NEW_ROOTFS} \
		--package.image_format=ext4 \
		--package.boot_mode=sd \
		--package.kernel_image=${NEW_IMAGE} \
		--package.defer_aie_run \
		--package.sd_file host.exe $(XCLBIN) libadf.a
	@echo "COMPLETE: hw package created."
endif
###################################################################################################

###########################################################################
# If the target is for HW_EMU, launch the emulator
# If the target is for HW, you'll have to follow the Confluence page for
# running on a board farm system.
run_emu:
ifeq (${TARGET},hw_emu)
	./launch_hw_emu.sh
else
	@echo "Hardware build, no emulation executed."
endif
###########################################################################

clean:
	rm -rf platform_repo build Work _x cfg emu_qemu_scripts qemu_dts_files sd_card sim
	rm -rf v++* *.log *.bin *.o *.xpe *.a *.bif *.exe *.sh *.BIN *.txt *.img *.xclbin
	rm -rf *.wcfg *.wdb .Xil cips*.json
